{
  "paragraphs": [
    {
      "text": "%md\n\n# Currying and Partially Applied Functions.\n\n### Building on Higher Order Functions.\n\nGiven what we learned about Higher Order Functions in the previous sections, and how they can be used to express flexible code in a concise manner (via a demonstration of taking imperative constructs and devising a functional implementation to overcome some of its shortcomings), It has been shown that being able to deal with functions as a kind of data is beneficial in and of itself.\n\nCurrying and Partially Applied Functions build on the concept of higher order functions, to allow for even further code flexibility.\n\n#### Currying\n\nHaving understood Higher Order Functions, it should now make sense to describe Currying as follows: \n\nA Curried function, is a multi parameter function, which instead of taking all parameters in one block, instead takes a single parameter at each position, and returns another function which takes the next argument in the sequence as its argument.  This continues up until the final parameter, at which point the arguments passed in are evaluated, and a results is returned.  \n\nFor a concrete example of this, consider the following simple yet frequently given example ... \n\n```scala\nval simpleAdd: (Int, Int) \u003d\u003e Int \u003d (x, y) \u003d\u003e x + y\nsimpleAdd(1, 2)\n```\nA standard scala function which takes two ints, and returns an int by adding them together.\n\n```scala\nval curriedAdd: Int \u003d\u003e Int \u003d\u003e Int \u003d x \u003d\u003e y \u003d\u003e x + y\ncurriedAdd(1)(2)\n```\n\nAnd now, the same function in curried form.  Note that the type of this val can be read as \u0027A function which takes an Int, and returns a function which takes an int and returns an int.\u0027\n\nThere are a few things of importance to note in the above curried function.  Firstly, the definition is using some scala syntactic sugar to make the definition of the function short.  In fact, it could be represented in a more concise manner using type inferance.\n\n```scala\nval curriedAddShortest \u003d (x: Int) \u003d\u003e (y: Int) \u003d\u003e x + y\n```\n\nHowever, it is beneficial to extract this out into its most verbose form for learning purposes: \n\n```scala\n\nval curriedAddVerbose: Int \u003d\u003e (Int \u003d\u003e Int) \u003d {\n  (x: Int) \u003d\u003e {\n    (y: Int) \u003d\u003e {\n      x + y\n    }\n  }\n}\n\n```\n\nWhen expressed in this form, it may be clearer to understand exactly what is going on with the function.\n\nIf we call the above function with the single parameter x, we see that the function body of this definition, itself returns a single parameter function which takes a y, and as its body defines that x and y should be added together.  It may seem that this all happens in one invokation of the function curriedAddVerbose, however this is not the case.  We should again look at the syntax of calling this curried function to understand how we are using it and the implications of currying.\n\n```scala\ncurriedAddVerbose(1)(2) \n/* vs */ \nsimpleAdd(1, 2)\n```\n \nIn the above example, what is actually happening in the invokation of curriedAddVerbose, is that the function which is being returned after the initial invokation (curriedAddVerbose(1)), is itself being immediately invoked with the argument 2, and then is discarded.  It would as well, be perfectly valid to perform the following operations:\n\n```scala\ncurriedAddVerbose(1)(2)     //3\ncurriedAddVerbose(1)        //Int \u003d\u003e Int\n\n//Just as we can assign the return of \u00273\u0027 to a variable, we may also assign our returned HOF for later use.\n\nval oneAdd \u003d curriedAddVerbose(1)\n\n/*\n*   At this point, oneAdd contains the following implementation\n*   (y: Int) \u003d\u003e {\n*        x + y\n*   }\n*/\n\noneAdd(4)   //5\noneAdd(6)   //7\noneAdd(1)   //2\n\n```\nIt is reasonable to ask, coming from an imperative background, just how this inner function may access the value of x even though it is in another scope, and especiialy as the duration of variables within functions is usually exhausted when the function which defines them ends.  \nThis requires a short aside to explain a property known as \u0027Closure\u0027.\n\n##### Closure\n\nClosure can in simple terms be thought of as the \u0027capture\u0027 of a variables state at an instance in time.  Closure is acheived, when an anonomous function or lambda, references a varible in a parent scope.  In our add examples, the first time our curried function is called with a single parameter, the value of x is set, and the next HOF in the chain is returned.  As this HOF itself references x.  The value which we previously injected is set within that function, and ready to be used when the final function in the chain is executed.\n\nThis is essentially all there is to Currying, though the usefulness of this technique may not be appearant in such a simple example, and we will return to a more complicated use later.\n\n\n#### Partially Applied Functions\n\nOnce Currying is understood, Paritially Applied Functions are much more readily understood.  A limitation which may jump out around Curried functions immediately, is that we must make a judgement call ahead of time regarding which parameters we would like to \u0027build up\u0027 and in which order.  For instance, if we have the following definition: \n\n```scala\nval sampleFun: Int \u003d\u003e Double \u003d\u003e String \u003d\u003e String \u003d \n  i \u003d\u003e d \u003d\u003e s \u003d\u003e {\n    s + s\"$d, $i\"\n  }\n```\nThen, we must be sure that we want to apply this function in the order Int, Double, and String.  As a general rule, it is best to think of parameter positions in curried functions as becoming more specialized and less general the further to the right in the parameter list we travel.\n\nParially Applied Functions functions overcome this limitation of needing to decide ahead of time the order of the inputs, and can generally be compared with Curried functions as follows:  Where a Curried function takes a single parameter and returns a function which itself takes a single parameter untill the final invokation where an evaluated result of those functions is return, a partially applied function may be a function of N parameters, on which an invokation of A parameters may take place in any order (where A \u003c\u003d N and A \u003e 0), which returns a new function which takes N - A parameters until the final invokation where a result is produced.\n\nFor a simple example: \n\n```scala\ndef count(one: Int, two: Int, three: Int): Unit \u003d {\n    Console println s\"$one, $two, $three\"\n}\n\n//May be invoked as: \n\nval missingMiddle \u003d count(1, _: Int, 3) // Int \u003d\u003e Unit\nmissingMiddle(2)    // \"1, 2, 3\"\n\n\n```\n\n### Using Curring and Partially Applied Functions to Solve Problems.\n\nCurrying and PAF\u0027s can be difficult to visualize a use for, however, there are two immediate benefits which can be realised when forming a system around them.  Consider the following system, which deals with payments:\n\n```scala\n\ntype Cardnumber           \u003d String\ntype Item                 \u003d String\ntype Price                \u003d Double\ntype Receipt              \u003d String\ntype Payment              \u003d (Cardnumber, Item, Price) \u003d\u003e Receipt\ntype SendInvoice          \u003d Receipt     \u003d\u003e Receipt\ntype PaymentValidation    \u003d Cardnumber  \u003d\u003e Boolean\ntype Checkout             \u003d Payment\n\nval performPayment: (PaymentValidation, Payment, SendInvoice, (Cardnumber, Item, Price)) \u003d\u003e Receipt \u003d {\n\n  (valid, pay, sendInvoice, details) \u003d\u003e {\n\n    val (card, item, price) \u003d details\n\n    if (valid(card)) {\n      val payment \u003d pay(card, item, price)\n      sendInvoice(payment)\n    } else {\n      \"This is an invalid card.\"\n    }\n  }\n}\n\nval cPerformPaymentCurried \u003d performPayment.curried\n\n```\n\nWe first define a top level function which deals with a payment.  It exists at a high level conceptually in the code, as it deals with many HOF\u0027s, until finally taking a card, item, and price, in order to evaluate its return.  The first three arguments in our function above are curried.  We will now see some functions which could be injected at these locations:\n\n```scala\n\nval isValidGoldCard   : PaymentValidation \u003d (cardnumber) \u003d\u003e cardnumber.length \u003d\u003d 4\nval isValidSilverCard : PaymentValidation \u003d (cardnumber) \u003d\u003e cardnumber.length \u003d\u003d 6\nval invoiceByPost     : SendInvoice \u003d (receipt) \u003d\u003e receipt + \"We have sent your invoice by post.\"\nval invoiceByEmail    : SendInvoice \u003d (receipt) \u003d\u003e receipt + \"We have sent your invoice by email.\"\nval payBySilvercard   : Payment \u003d (card, item, price) \u003d\u003e s\"Your Receipt for the Silver Card: $card | $item | €$price\\n\"\nval payByGoldcard     : Payment \u003d (card, item, price)     \u003d\u003e s\"Your Receipt for the Gold Card: $card | $item | €$price\\n\"\n\n```\n\nThe Types of these functions match the types in the the function signiture of our cPerformPaymentMethod, so we may build up a chain of computations by applying those functions: \n\n```scala\n\nval goldMemberService   \u003d cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\nval silverMemberService \u003d cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\n\nval goldPurchase    \u003d silverMemberService(invoiceByPost)\nval silverPurchase  \u003d goldMemberService(invoiceByPost)\n\n```\n\nWe have now built two distinct functions, which are ready to be applied to their final arguments to be evaluated to a result.\n\n```scala\n\nsilverPurchase(\"1234\", \"Table Set\", 100.0)  //This is an invalid card.\n\ngoldPurchase(\"1234\", \"Table Set\", 100.0)    //Your Receipt for the Gold Card: 1234 | Table Set | €100.0\n                                            //We have sent your invoice by post.\n\n```\n\nThere are two important things to note here.\n\n1. We formed a new implementation based off existing functionality via injecting and building our computation an argument at a time.\n\nThis first property allows for easy testing, when we consider that in our testing functions, we could just as easiliy apply a mock function.  The following defines a test utility function which always evaluates to true, and builds up a test function which would imply that the \u0027payByGoldcard\u0027 is being tested for some property.\n\n```scala\nval MOCKED_VALIDATION: PaymentValidation \u003d (_) \u003d\u003e true\nval payByGoldCardTestFun \u003d cPerformPaymentCurried(MOCKED_VALIDATION)(payByGoldcard)\n\n```\n\n2. The final stage of the function invokation has no concept of the outer services which define its implementation.\n\nAt the final stage of the invokation, the arguments which we apply relate directly to the item we are purchasing.  In an imperative realm, provided we have no external global state, this would imply that all of the validation and other processing defined in the business process, would be carried out and instanciated within the function, which would make the function very hard, if not impossible to test.\n\nHowever, with currying, we were able to inject our dependencies early in the formation of a few top level functions, and avoid the noise of explicitly passing our dependencies to every function which uses them.  We instead, can focus on only passing in the concrete product we wish to deal with.\n\nCurrying and Partially Applied Functions provide a powerful mechanism for composing a system via a series of curried and partially applied functions, which are finally applied to their concrete arguments at the periphery of the system directly at the IO interface in the code.  All of this is possible while still maintaining flexibility, and makes for easy testing without any additional frameworks or boilerplate, by using only functional programming features.\n\n\n\n\n\n",
      "user": "anonymous",
      "dateUpdated": "Mar 3, 2017 10:44:41 AM",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true
        },
        "editorMode": "ace/mode/markdown",
        "colWidth": 9.0,
        "editorHide": true,
        "results": [
          {
            "graph": {
              "mode": "table",
              "height": 4423.390625,
              "optionOpen": false,
              "keys": [],
              "values": [],
              "groups": [],
              "scatter": {}
            }
          }
        ],
        "enabled": true,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        }
      },
      "settings": {
        "params": {
          "payBy": ""
        },
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1488537715956_1351579140",
      "id": "20170130-221237_1038500617",
      "result": {
        "code": "SUCCESS",
        "type": "HTML",
        "msg": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eCurrying and Partially Applied Functions.\u003c/h1\u003e\n\u003ch3\u003eBuilding on Higher Order Functions.\u003c/h3\u003e\n\u003cp\u003eGiven what we learned about Higher Order Functions in the previous sections, and how they can be used to express flexible code in a concise manner (via a demonstration of taking imperative constructs and devising a functional implementation to overcome some of its shortcomings), It has been shown that being able to deal with functions as a kind of data is beneficial in and of itself.\u003c/p\u003e\n\u003cp\u003eCurrying and Partially Applied Functions build on the concept of higher order functions, to allow for even further code flexibility.\u003c/p\u003e\n\u003ch4\u003eCurrying\u003c/h4\u003e\n\u003cp\u003eHaving understood Higher Order Functions, it should now make sense to describe Currying as follows: \u003c/p\u003e\n\u003cp\u003eA Curried function, is a multi parameter function, which instead of taking all parameters in one block, instead takes a single parameter at each position, and returns another function which takes the next argument in the sequence as its argument. This continues up until the final parameter, at which point the arguments passed in are evaluated, and a results is returned. \u003c/p\u003e\n\u003cp\u003eFor a concrete example of this, consider the following simple yet frequently given example \u0026hellip; \u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003eval simpleAdd: (Int, Int) \u003d\u0026gt; Int \u003d (x, y) \u003d\u0026gt; x + y\nsimpleAdd(1, 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA standard scala function which takes two ints, and returns an int by adding them together.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003eval curriedAdd: Int \u003d\u0026gt; Int \u003d\u0026gt; Int \u003d x \u003d\u0026gt; y \u003d\u0026gt; x + y\ncurriedAdd(1)(2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now, the same function in curried form. Note that the type of this val can be read as \u0026lsquo;A function which takes an Int, and returns a function which takes an int and returns an int.\u0026rsquo;\u003c/p\u003e\n\u003cp\u003eThere are a few things of importance to note in the above curried function. Firstly, the definition is using some scala syntactic sugar to make the definition of the function short. In fact, it could be represented in a more concise manner using type inferance.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003eval curriedAddShortest \u003d (x: Int) \u003d\u0026gt; (y: Int) \u003d\u0026gt; x + y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, it is beneficial to extract this out into its most verbose form for learning purposes: \u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003e\u003cbr/\u003eval curriedAddVerbose: Int \u003d\u0026gt; (Int \u003d\u0026gt; Int) \u003d {\n  (x: Int) \u003d\u0026gt; {\n    (y: Int) \u003d\u0026gt; {\n      x + y\n    }\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen expressed in this form, it may be clearer to understand exactly what is going on with the function.\u003c/p\u003e\n\u003cp\u003eIf we call the above function with the single parameter x, we see that the function body of this definition, itself returns a single parameter function which takes a y, and as its body defines that x and y should be added together. It may seem that this all happens in one invokation of the function curriedAddVerbose, however this is not the case. We should again look at the syntax of calling this curried function to understand how we are using it and the implications of currying.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003ecurriedAddVerbose(1)(2) \n/* vs */ \nsimpleAdd(1, 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the above example, what is actually happening in the invokation of curriedAddVerbose, is that the function which is being returned after the initial invokation (curriedAddVerbose(1)), is itself being immediately invoked with the argument 2, and then is discarded. It would as well, be perfectly valid to perform the following operations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003ecurriedAddVerbose(1)(2)     //3\ncurriedAddVerbose(1)        //Int \u003d\u0026gt; Int\n\n//Just as we can assign the return of \u0026#39;3\u0026#39; to a variable, we may also assign our returned HOF for later use.\n\nval oneAdd \u003d curriedAddVerbose(1)\n\n/*\n*   At this point, oneAdd contains the following implementation\n*   (y: Int) \u003d\u0026gt; {\n*        x + y\n*   }\n*/\n\noneAdd(4)   //5\noneAdd(6)   //7\noneAdd(1)   //2\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is reasonable to ask, coming from an imperative background, just how this inner function may access the value of x even though it is in another scope, and especiialy as the duration of variables within functions is usually exhausted when the function which defines them ends.\u003cbr/\u003eThis requires a short aside to explain a property known as \u0026lsquo;Closure\u0026rsquo;.\u003c/p\u003e\n\u003ch5\u003eClosure\u003c/h5\u003e\n\u003cp\u003eClosure can in simple terms be thought of as the \u0026lsquo;capture\u0026rsquo; of a variables state at an instance in time. Closure is acheived, when an anonomous function or lambda, references a varible in a parent scope. In our add examples, the first time our curried function is called with a single parameter, the value of x is set, and the next HOF in the chain is returned. As this HOF itself references x. The value which we previously injected is set within that function, and ready to be used when the final function in the chain is executed.\u003c/p\u003e\n\u003cp\u003eThis is essentially all there is to Currying, though the usefulness of this technique may not be appearant in such a simple example, and we will return to a more complicated use later.\u003c/p\u003e\n\u003ch4\u003ePartially Applied Functions\u003c/h4\u003e\n\u003cp\u003eOnce Currying is understood, Paritially Applied Functions are much more readily understood. A limitation which may jump out around Curried functions immediately, is that we must make a judgement call ahead of time regarding which parameters we would like to \u0026lsquo;build up\u0026rsquo; and in which order. For instance, if we have the following definition: \u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003eval sampleFun: Int \u003d\u0026gt; Double \u003d\u0026gt; String \u003d\u0026gt; String \u003d \n  i \u003d\u0026gt; d \u003d\u0026gt; s \u003d\u0026gt; {\n    s + s\u0026quot;$d, $i\u0026quot;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, we must be sure that we want to apply this function in the order Int, Double, and String. As a general rule, it is best to think of parameter positions in curried functions as becoming more specialized and less general the further to the right in the parameter list we travel.\u003c/p\u003e\n\u003cp\u003eParially Applied Functions functions overcome this limitation of needing to decide ahead of time the order of the inputs, and can generally be compared with Curried functions as follows: Where a Curried function takes a single parameter and returns a function which itself takes a single parameter untill the final invokation where an evaluated result of those functions is return, a partially applied function may be a function of N parameters, on which an invokation of A parameters may take place in any order (where A \u0026lt;\u003d N and A \u0026gt; 0), which returns a new function which takes N - A parameters until the final invokation where a result is produced.\u003c/p\u003e\n\u003cp\u003eFor a simple example: \u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003edef count(one: Int, two: Int, three: Int): Unit \u003d {\n    Console println s\u0026quot;$one, $two, $three\u0026quot;\n}\n\n//May be invoked as: \n\nval missingMiddle \u003d count(1, _: Int, 3) // Int \u003d\u0026gt; Unit\nmissingMiddle(2)    // \u0026quot;1, 2, 3\u0026quot;\n\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eUsing Curring and Partially Applied Functions to Solve Problems.\u003c/h3\u003e\n\u003cp\u003eCurrying and PAF\u0026rsquo;s can be difficult to visualize a use for, however, there are two immediate benefits which can be realised when forming a system around them. Consider the following system, which deals with payments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003e\u003cbr/\u003etype Cardnumber           \u003d String\ntype Item                 \u003d String\ntype Price                \u003d Double\ntype Receipt              \u003d String\ntype Payment              \u003d (Cardnumber, Item, Price) \u003d\u0026gt; Receipt\ntype SendInvoice          \u003d Receipt     \u003d\u0026gt; Receipt\ntype PaymentValidation    \u003d Cardnumber  \u003d\u0026gt; Boolean\ntype Checkout             \u003d Payment\n\nval performPayment: (PaymentValidation, Payment, SendInvoice, (Cardnumber, Item, Price)) \u003d\u0026gt; Receipt \u003d {\n\n  (valid, pay, sendInvoice, details) \u003d\u0026gt; {\n\n    val (card, item, price) \u003d details\n\n    if (valid(card)) {\n      val payment \u003d pay(card, item, price)\n      sendInvoice(payment)\n    } else {\n      \u0026quot;This is an invalid card.\u0026quot;\n    }\n  }\n}\n\nval cPerformPaymentCurried \u003d performPayment.curried\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe first define a top level function which deals with a payment. It exists at a high level conceptually in the code, as it deals with many HOF\u0026rsquo;s, until finally taking a card, item, and price, in order to evaluate its return. The first three arguments in our function above are curried. We will now see some functions which could be injected at these locations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003e\u003cbr/\u003eval isValidGoldCard   : PaymentValidation \u003d (cardnumber) \u003d\u0026gt; cardnumber.length \u003d\u003d 4\nval isValidSilverCard : PaymentValidation \u003d (cardnumber) \u003d\u0026gt; cardnumber.length \u003d\u003d 6\nval invoiceByPost     : SendInvoice \u003d (receipt) \u003d\u0026gt; receipt + \u0026quot;We have sent your invoice by post.\u0026quot;\nval invoiceByEmail    : SendInvoice \u003d (receipt) \u003d\u0026gt; receipt + \u0026quot;We have sent your invoice by email.\u0026quot;\nval payBySilvercard   : Payment \u003d (card, item, price) \u003d\u0026gt; s\u0026quot;Your Receipt for the Silver Card: $card | $item | €$price\\n\u0026quot;\nval payByGoldcard     : Payment \u003d (card, item, price)     \u003d\u0026gt; s\u0026quot;Your Receipt for the Gold Card: $card | $item | €$price\\n\u0026quot;\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Types of these functions match the types in the the function signiture of our cPerformPaymentMethod, so we may build up a chain of computations by applying those functions: \u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003e\u003cbr/\u003eval goldMemberService   \u003d cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\nval silverMemberService \u003d cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\n\nval goldPurchase    \u003d silverMemberService(invoiceByPost)\nval silverPurchase  \u003d goldMemberService(invoiceByPost)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe have now built two distinct functions, which are ready to be applied to their final arguments to be evaluated to a result.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003e\u003cbr/\u003esilverPurchase(\u0026quot;1234\u0026quot;, \u0026quot;Table Set\u0026quot;, 100.0)  //This is an invalid card.\n\ngoldPurchase(\u0026quot;1234\u0026quot;, \u0026quot;Table Set\u0026quot;, 100.0)    //Your Receipt for the Gold Card: 1234 | Table Set | €100.0\n                                            //We have sent your invoice by post.\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are two important things to note here.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eWe formed a new implementation based off existing functionality via injecting and building our computation an argument at a time.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis first property allows for easy testing, when we consider that in our testing functions, we could just as easiliy apply a mock function. The following defines a test utility function which always evaluates to true, and builds up a test function which would imply that the \u0026lsquo;payByGoldcard\u0026rsquo; is being tested for some property.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class\u003d\"scala\"\u003eval MOCKED_VALIDATION: PaymentValidation \u003d (_) \u003d\u0026gt; true\nval payByGoldCardTestFun \u003d cPerformPaymentCurried(MOCKED_VALIDATION)(payByGoldcard)\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n  \u003cli\u003eThe final stage of the function invokation has no concept of the outer services which define its implementation.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAt the final stage of the invokation, the arguments which we apply relate directly to the item we are purchasing. In an imperative realm, provided we have no external global state, this would imply that all of the validation and other processing defined in the business process, would be carried out and instanciated within the function, which would make the function very hard, if not impossible to test.\u003c/p\u003e\n\u003cp\u003eHowever, with currying, we were able to inject our dependencies early in the formation of a few top level functions, and avoid the noise of explicitly passing our dependencies to every function which uses them. We instead, can focus on only passing in the concrete product we wish to deal with.\u003c/p\u003e\n\u003cp\u003eCurrying and Partially Applied Functions provide a powerful mechanism for composing a system via a series of curried and partially applied functions, which are finally applied to their concrete arguments at the periphery of the system directly at the IO interface in the code. All of this is possible while still maintaining flexibility, and makes for easy testing without any additional frameworks or boilerplate, by using only functional programming features.\u003c/p\u003e\n\u003c/div\u003e"
      },
      "dateCreated": "Mar 3, 2017 10:41:55 AM",
      "dateStarted": "Mar 3, 2017 10:44:41 AM",
      "dateFinished": "Mar 3, 2017 10:44:41 AM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    },
    {
      "text": "",
      "user": "anonymous",
      "dateUpdated": "Mar 3, 2017 10:44:41 AM",
      "config": {
        "editorSetting": {
          "language": "scala"
        },
        "editorMode": "ace/mode/scala",
        "colWidth": 12.0,
        "results": {},
        "enabled": true,
        "graph": {
          "mode": "table",
          "height": 300.0,
          "optionOpen": false,
          "keys": [],
          "values": [],
          "groups": [],
          "scatter": {}
        }
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "jobName": "paragraph_1488537715957_1351194392",
      "id": "20170201-175546_248826486",
      "result": {
        "code": "SUCCESS",
        "type": "TEXT",
        "msg": ""
      },
      "dateCreated": "Mar 3, 2017 10:41:55 AM",
      "dateStarted": "Mar 3, 2017 10:44:48 AM",
      "dateFinished": "Mar 3, 2017 10:44:48 AM",
      "status": "FINISHED",
      "progressUpdateIntervalMs": 500
    }
  ],
  "name": "Liam/Currying",
  "id": "2C9P4STFP",
  "angularObjects": {
    "2C7EWGKXN:shared_process": [],
    "2CAGPJ93Y:shared_process": [],
    "2C8HKHF53:shared_process": [],
    "2C9X1SS4K:shared_process": [],
    "2C7C4ENCY:shared_process": [],
    "2C7KTHZNU:shared_process": [],
    "2C7RVPZ3W:shared_process": [],
    "2C9BA4F3E:shared_process": [],
    "2CAGV9SKG:shared_process": []
  },
  "config": {},
  "info": {}
}