{"paragraphs":[{"text":"%md\n\n# Higher Order Functions\n\n### Functions as First Class Citizens\nOne of the defining characteristics of functional languages, is the treatment of functions as first class citizens within the paradigm.  What is meant by this, is that functions within the language should be capable of being:  \n\n1. Named by variables\n2. Passed as arguments to functions\n3. Returned as results from functions\n4. Can be included in Data-Structures\n\n### Demonstrations of the above properties\n\n<br>\n##### 1. Named/referenced by variable\n\n```scala\n\n// A function which takes an integer x, and returns that value doubled\nval double = (x: Int) => x * 2\ndouble(4) // produces `8`\n\nval doubleAlias = double\ndoubleAlias(5) // produces 10\n```\n\nIn the above example, we have simply defined a function type, and assigned it to a `val` named double.\nInvokation of the defined function can be acheived by passing the required arguments, or in the case of functions with no arguments, empty parenthesis.\n\n<br>\n\n##### 2. Passed as arguments to functions\n\n```scala\n\nval double = (x: Int) => x * 2\nval funcAcceptingFunc = (f: (Int) => Int, number: Int) => f(number) * number\n\nfuncAcceptingFunc(double, 2) // produces `8`\n\n//Note that `funcAcceptingFunc' does not care about the implementation of f, only that it takes an Int \n//and returns an Int.  This in some ways for programmers coming from OOP background can be likend to a poly //morphic method, though without all the inheritance hierarchy needed to acheive it!\n\n```\n\nIn the rather contrived example above, we have defined two functions.\n\nThe first function `double`, simply takes an `Int`, and multiplies it by 2 to produce an `Int`.  The type of this val is therefore: `(Int) => Int`.  The second function `funcAcceptingFunc`, takes **any** function of type `(Int) => Int`, and names it `f` for the duration of the function.  It additionally accepts an argument `number`, which is of type `Int`.  The body of this function, calls the passed in function with the argument `number`, and multiplies the return of that call by `number`.  \n\nFor now, simply appreciate the mechanics of this function passing approach.  The benefits of such an approach will be explained in a more concrete and applicable to everyday programming example shortly.  \n\n<br>\n\n##### 3. Returned as results from functions\n\n```scala\n\nval decideWhichPostalServiceToUse = (letterAddress: String) => {\n    if(letterAddress == \"America\") {\n        \n        // Note that just like other first class entities in the language, \n        // function literals (unnamed) may be created without explicit names.\n        // For example, 5 is simply an `Int` which has no name assigned to it.\n        \n        (letterContent: String) => println(s\"Sending $letterContent, via internation post!\")\n    } else {\n        (letterContent: String) => println(s\"Sending via national post!\")\n    }\n}\n\nval letterAddress = \"America\"\nval letterContent = \"Hello from Ireland\"\n\n// Will return the appropriate mail dispatcher\nval postalService = decideWhichPostalServiceToUse(letterAddress)\n\npostalService(letterContent) // Will println out \"Sending Hello from Ireland, via international post!\"\n\n```\n\nAgain, via a rather contrieved example, the mechanics of returning a function from another function are simply to have that function as the last statement in the invoked function.\n\n<br>\n\n##### 4. Can be included in Data-Structures\n\nAgain, for simplicity, a perhaps not all too realistic example: \n\n```scala \n\n// In this case, our functions take no parameters.\nval byCreditCard    = () => \"asked for pin\"\nval byCash          = () => \"wrote reciept\"\nval byTab           = () => \"started tab\"\n\n// Store all possible actions when paying in a Map.\nval payBy           = Map(\"card\" -> byCreditCard, \"cash\" -> byCash, \"tab\" -> byTab)\n\n// Suppose now we have a customer ... \nval bob = \"Bob\"\n\n// And a function which allows him to pay ... \nval cashier = (customer: String, amount: Double, methodOfPayment: String) => {\n    \n    // Lookup the desired funtion in our datastructure.\n    val dealWithPayment = payBy(methodOfPayment)\n    \n    // Invoke the function\n    val whatCashierDid = dealWithPayment()\n\n    println(s\"$customer payed $amount.  Cashier $whatCashierDid\")\n    \n}\n\n// We may now execute a payment via ... \n\ncashier(bob, 100.0, \"cash\") // Prints:  Bob payed 100.0.  Cashier wrote reciept\ncashier(bob, 100.0, \"card\") // Prints:  Bob payed 100.0.  Cashier asked for pin\ncashier(bob, 100.0, \"tab\")  // Prints:  Bob payed 100.0.  Cashier started tab\n\n```\n\n<br>\n\n### First Class Functions Enable Higher Order Functions\n\nA Higher Order Function (HOF), is simply realised by a language treating functions as first class citizens. They are concretely, functions which take a function as a parameter, or return another function as a result, as in some of the examples above.  This is useful for many reasons, and not only in acedemic or made up examples.  In order to identify one of the most widely used applications of HOF's, it may be beneficial to first step back to a more Imperative approach to programming ... ","dateUpdated":"2017-02-01T14:37:18+0000","config":{"enabled":true,"tableHide":false,"graph":{"mode":"table","height":1358,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":7},"settings":{"params":{"payBy":""},"forms":{}},"jobName":"paragraph_1485959799210_939530352","id":"20170130-221237_1038500617","result":{"code":"SUCCESS","type":"HTML","msg":"<h1>Higher Order Functions</h1>\n<h3>Functions as First Class Citizens</h3>\n<p>One of the defining characteristics of functional languages, is the treatment of functions as first class citizens within the paradigm.  What is meant by this, is that functions within the language should be capable of being:</p>\n<ol>\n<li>Named by variables</li>\n<li>Passed as arguments to functions</li>\n<li>Returned as results from functions</li>\n<li>Can be included in Data-Structures</li>\n</ol>\n<h3>Demonstrations of the above properties</h3>\n<p><br></p>\n<h5>1. Named/referenced by variable</h5>\n<pre><code class=\"scala\">// A function which takes an integer x, and returns that value doubled\nval double = (x: Int) =&gt; x * 2\ndouble(4) // produces `8`\n\nval doubleAlias = double\ndoubleAlias(5) // produces 10\n</code></pre>\n<p>In the above example, we have simply defined a function type, and assigned it to a <code>val</code> named double.\n<br  />Invokation of the defined function can be acheived by passing the required arguments, or in the case of functions with no arguments, empty parenthesis.</p>\n<p><br></p>\n<h5>2. Passed as arguments to functions</h5>\n<pre><code class=\"scala\">val double = (x: Int) =&gt; x * 2\nval funcAcceptingFunc = (f: (Int) =&gt; Int, number: Int) =&gt; f(number) * number\n\nfuncAcceptingFunc(double, 2) // produces `8`\n\n//Note that `funcAcceptingFunc' does not care about the implementation of f, only that it takes an Int \n//and returns an Int.  This in some ways for programmers coming from OOP background can be likend to a poly //morphic method, though without all the inheritance hierarchy needed to acheive it!\n</code></pre>\n<p>In the rather contrived example above, we have defined two functions.</p>\n<p>The first function <code>double</code>, simply takes an <code>Int</code>, and multiplies it by 2 to produce an <code>Int</code>.  The type of this val is therefore: <code>(Int) =&gt; Int</code>.  The second function <code>funcAcceptingFunc</code>, takes <strong>any</strong> function of type <code>(Int) =&gt; Int</code>, and names it <code>f</code> for the duration of the function.  It additionally accepts an argument <code>number</code>, which is of type <code>Int</code>.  The body of this function, calls the passed in function with the argument <code>number</code>, and multiplies the return of that call by <code>number</code>.</p>\n<p>For now, simply appreciate the mechanics of this function passing approach.  The benefits of such an approach will be explained in a more concrete and applicable to everyday programming example shortly.</p>\n<p><br></p>\n<h5>3. Returned as results from functions</h5>\n<pre><code class=\"scala\">val decideWhichPostalServiceToUse = (letterAddress: String) =&gt; {\n    if(letterAddress == \"America\") {\n\n        // Note that just like other first class entities in the language, \n        // function literals (unnamed) may be created without explicit names.\n        // For example, 5 is simply an `Int` which has no name assigned to it.\n\n        (letterContent: String) =&gt; println(s\"Sending $letterContent, via internation post!\")\n    } else {\n        (letterContent: String) =&gt; println(s\"Sending via national post!\")\n    }\n}\n\nval letterAddress = \"America\"\nval letterContent = \"Hello from Ireland\"\n\n// Will return the appropriate mail dispatcher\nval postalService = decideWhichPostalServiceToUse(letterAddress)\n\npostalService(letterContent) // Will println out \"Sending Hello from Ireland, via international post!\"\n</code></pre>\n<p>Again, via a rather contrieved example, the mechanics of returning a function from another function are simply to have that function as the last statement in the invoked function.</p>\n<p><br></p>\n<h5>4. Can be included in Data-Structures</h5>\n<p>Again, for simplicity, a perhaps not all too realistic example:</p>\n<pre><code class=\"scala\">// In this case, our functions take no parameters.\nval byCreditCard    = () =&gt; \"asked for pin\"\nval byCash          = () =&gt; \"wrote reciept\"\nval byTab           = () =&gt; \"started tab\"\n\n// Store all possible actions when paying in a Map.\nval payBy           = Map(\"card\" -&gt; byCreditCard, \"cash\" -&gt; byCash, \"tab\" -&gt; byTab)\n\n// Suppose now we have a customer ... \nval bob = \"Bob\"\n\n// And a function which allows him to pay ... \nval cashier = (customer: String, amount: Double, methodOfPayment: String) =&gt; {\n\n    // Lookup the desired funtion in our datastructure.\n    val dealWithPayment = payBy(methodOfPayment)\n\n    // Invoke the function\n    val whatCashierDid = dealWithPayment()\n\n    println(s\"$customer payed $amount.  Cashier $whatCashierDid\")\n\n}\n\n// We may now execute a payment via ... \n\ncashier(bob, 100.0, \"cash\") // Prints:  Bob payed 100.0.  Cashier wrote reciept\ncashier(bob, 100.0, \"card\") // Prints:  Bob payed 100.0.  Cashier asked for pin\ncashier(bob, 100.0, \"tab\")  // Prints:  Bob payed 100.0.  Cashier started tab\n</code></pre>\n<p><br></p>\n<h3>First Class Functions Enable Higher Order Functions</h3>\n<p>A Higher Order Function (HOF), is simply realised by a language treating functions as first class citizens. They are concretely, functions which take a function as a parameter, or return another function as a result, as in some of the examples above.  This is useful for many reasons, and not only in acedemic or made up examples.  In order to identify one of the most widely used applications of HOF's, it may be beneficial to first step back to a more Imperative approach to programming &hellip;</p>\n"},"dateCreated":"2017-02-01T14:36:39+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:781","dateFinished":"2017-02-01T14:37:17+0000","dateStarted":"2017-02-01T14:37:17+0000"},{"title":"Click run for an outline of Scala syntax needed for this discussion","text":"%md \n\n### Values and Variables\n\nIn Scala, Immutable values are encouraged.  In place of variables, `val`s are more commonly used as the default declaration for a value.\n\n```scala\nval x: Int = 5\nx = 6 //Not allowed!\n```\n\nThe above essentially equivalent to a final int in Java.\n\n```scala \nvar x: Int = 5\nx = 6 //Allowed, but not encouraged!\n```\n\n### Type Inference for Less Boilerplate\n\nIt should be appearant that the general form for declaring a variable in Scala follows the pattern:  \n\n```scala \n// var|val <Variable_name>: <Variable_Type> = <Value\nval x: Int = 5\n```\n\nThis is fine, and perfectly readable, however as we shall see later, the types in scala may become particularly complex.  To help with this, Scala uses a mechanism known as `Type Inference`, which allows the compiler to infer the type of a variable where ever possible.  \n\nThis allows us to write the following: \n\n```scala\nval x = 5\nval s = \"Type Inference is Awesome!\"\n```\n\n\n### Function Types\n\nAs Scala is both and Object Oriented and Functional language, it makes sure to differenciate clearly between `functions` and `methods`.\n\nA method exists inside a class, and is very similar to Java's methods:\n\n```scala\nclass FunkyFuncs {\n    \n    def myMethod(x: Int, y: Int): Int = {\n        return x + y\n    }\n    \n    //Note however, that the final line in a Scala function\n    //is the methods return value.  Additionally using type inference\n    //and lack of a requirement for parathesis around a single \n    //line function, the above may be also constructed as ... \n    \n    def myMethodShorter(x: Int, y: Int) = x + y\n    \n}\n```\n\nA function on the other hand, is essentially a variable which is assigned a function definition.  IE, a value which takes 0 or more arguments, and returns a value as a result.\n\n```scala\nval f: (Int, Int) => Int = (x, y) => x + y\nf(1, 3) // Produces `4`\n\n//Or with Type Inference!\nval f = (x: Int, y: Int) => x + y\n```\n\nWe can now see that function definitions take the form:\n```\nval|var <name>: (<arg0>, ... , <argN>) => <body> \n```","dateUpdated":"2017-02-01T14:37:20+0000","config":{"enabled":true,"title":true,"tableHide":false,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":5},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1485959799210_939530352","id":"20170131-190426_1304703861","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Values and Variables</h3>\n<p>In Scala, Immutable values are encouraged.  In place of variables, <code>val</code>s are more commonly used as the default declaration for a value.</p>\n<pre><code class=\"scala\">val x: Int = 5\nx = 6 //Not allowed!\n</code></pre>\n<p>The above essentially equivalent to a final int in Java.</p>\n<pre><code class=\"scala\">var x: Int = 5\nx = 6 //Allowed, but not encouraged!\n</code></pre>\n<h3>Type Inference for Less Boilerplate</h3>\n<p>It should be appearant that the general form for declaring a variable in Scala follows the pattern:</p>\n<pre><code class=\"scala\">// var|val &lt;Variable_name&gt;: &lt;Variable_Type&gt; = &lt;Value\nval x: Int = 5\n</code></pre>\n<p>This is fine, and perfectly readable, however as we shall see later, the types in scala may become particularly complex.  To help with this, Scala uses a mechanism known as <code>Type Inference</code>, which allows the compiler to infer the type of a variable where ever possible.</p>\n<p>This allows us to write the following:</p>\n<pre><code class=\"scala\">val x = 5\nval s = \"Type Inference is Awesome!\"\n</code></pre>\n<h3>Function Types</h3>\n<p>As Scala is both and Object Oriented and Functional language, it makes sure to differenciate clearly between <code>functions</code> and <code>methods</code>.</p>\n<p>A method exists inside a class, and is very similar to Java's methods:</p>\n<pre><code class=\"scala\">class FunkyFuncs {\n\n    def myMethod(x: Int, y: Int): Int = {\n        return x + y\n    }\n\n    //Note however, that the final line in a Scala function\n    //is the methods return value.  Additionally using type inference\n    //and lack of a requirement for parathesis around a single \n    //line function, the above may be also constructed as ... \n\n    def myMethodShorter(x: Int, y: Int) = x + y\n\n}\n</code></pre>\n<p>A function on the other hand, is essentially a variable which is assigned a function definition.  IE, a value which takes 0 or more arguments, and returns a value as a result.</p>\n<pre><code class=\"scala\">val f: (Int, Int) =&gt; Int = (x, y) =&gt; x + y\nf(1, 3) // Produces `4`\n\n//Or with Type Inference!\nval f = (x: Int, y: Int) =&gt; x + y\n</code></pre>\n<p>We can now see that function definitions take the form:</p>\n<pre><code>val|var &lt;name&gt;: (&lt;arg0&gt;, ... , &lt;argN&gt;) =&gt; &lt;body&gt; \n</code></pre>\n"},"dateCreated":"2017-02-01T14:36:39+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:782","dateFinished":"2017-02-01T14:37:17+0000","dateStarted":"2017-02-01T14:37:17+0000"},{"text":"%md\n\n### Imperative vs Functional Sequence Loop\n\n##### The Imperative Approach \n\nLooping over collections of objects or primative types occurs everywhere in imperative programming.  Every imperative programmer will be familiar with `for` loops in particular.  Consider the follow snippet in Java: \n\n```java\n\npublic static ArrayList<String> convertToUpperCase(ArrayList<String> theList) {\n\n    for(int i = 0; i < theList.size(); i++) {\n\t    theList.set(i, theList.get(i).toUpperCase());\n    }\n\n    return theList;\n}\n  \npublic static void main(String[] args) {    \n\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"liam\");\n    names.add(\"david\");\n    names.add(\"sam\");\n    names.add(\"jerry\");\n    convertToUpperCase(names);\n    System.out.print(names);  // Prints [LIAM, DAVID, SAM, JERRY]\n}\n\n```\n\nIn the typically imperative style, the programmer outlines exactly how the execution of the program will proceed.  It is an abstraction over the machine, which provides an easier and higher level way of using register counters and boolean tests to loop over a sequence.  *Initialise an `int` counter named `i`, test to see if `i` is less than the size of our sequence, if it is, progress, if not halt.  During the loop, perform some operation and finish the loop body by `incrementing` the loop counter.*\n\nSome time passes, and we now realise that we wish to add a title to each of the names in our collection:\n\n```java\n\npublic static ArrayList<String> prependTitle(ArrayList<String> theList) {\n\n    for(int i = 0; i < theList.size(); i++) {\n\t    theList.set(i, \"MR. \" + theList.get(i));\n    }\n\n    return theList;\n}\n\npublic static ArrayList<String> convertToUpperCase(ArrayList<String> theList) {\n\n    for(int i = 0; i < theList.size(); i++) {\n\t    theList.set(i, theList.get(i).toUpperCase());\n    }\n\n    return theList;\n}\n  \npublic static void main(String[] args) {    \n\n    ArrayList<String> names = new ArrayList<>();\n    names.add(\"liam\");\n    names.add(\"david\");\n    names.add(\"sam\");\n    names.add(\"jerry\");\n    convertToUpperCase(names);\n    prependTitle(names);\n    System.out.print(names);  // Prints [MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY]\n}\n```\n\nWe have introduced an additional function named `prependTitle`, which performs another operation on our list before returning.  The similarities in form between the two functions should be readily visible in this simplified form.  However, we are forced to implement the same loop two in order to before these two operations to our ArrayList of Strings.  This not only leads to a greater amount of code, but also introduces more chance for logic errors, and index out of bounds exceptions.  Index out of bounds exceptions could of course be eliminated via a more advanced foreach loop on this particular collection, however we are still faced with the duplicated logic of the extremely common task of **looping over each item in a collection once, and applying some operation to the data at the position**\n\n##### Eliminating Code Duplication, and Providing a Higher Level of Abstraction via HOFs\n\nAs an example of how the above Java can be expressed in a more abstract way using what we know already about Higher Order Functions, and Functions as first class citizens.\n\nWe will proceed from our existing implementation converted to Scala: \n\n```scala\n\n/**\n    * Scala has no concept of a for loop, though we implement\n    * the same using a while.\n    * Scala additionally does not allow the passing of mutable/changeable\n    * references in to functions, for reasons which will be described\n    * much later.\n    */\n\n  val prependTitle = (theList: List[String]) => {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i < theList.size) {\n      alteredList = (\"MR. \" + theList(i)) :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  val convertToUpperCase = (theList: List[String]) => {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i < theList.size) {\n      alteredList = theList(i).toUpperCase :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n  names = convertToUpperCase(names)\n  println(names) // Prints: List(JERRY, SAM, DAVID, LIAM)\n\n  names = prependTitle(names)\n  println(names) // Prints: List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n  \n```\n\nTo take advantage of HOF's to solve our code duplication issue, we should first factor out what is common between the functions `prependTitle`, and `convertToUppercase`.  The code which we are seeking to abstract over, can be summed up as follows: \n\n```\nperformActionToList(theList, performSomeActionToElement):\n    i = 0\n    while i < theList:\n        theList = theList.updated(i, `performSomeActionToElement(theList(i))`)\n        i = i + 1\n    return theList\n```\n\nWe can see from the above sample, that `performSomeActionToElement(theList(i))`, is a prime condidate for abstracting a loop via HOF's.  In this case, our `performSomeActionToElement(theList(i))` type, is a function which takes some element of type T, and returns a T as its result.  For a more concrete example in Scala, \nwe will now factor out our loop:\n\n```scala\n\n// Our new factored out looping construct\n\n  val performActionToList = (theList: List[String], performSomeActionToElement: (String) => String) => {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i < theList.size) {\n      alteredList = performSomeActionToElement(theList(i)) :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  // Our new restructured operations on our collection\n  val convertToUpperCase  = (theList: List[String]) => performActionToList(theList, (elem: String) => elem.toUpperCase)\n  val prependTitle        = (theList: List[String]) => performActionToList(theList, (elem: String) => \"MR. \" + elem)\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n  names = convertToUpperCase(names)\n  println(names) // Prints:  List(JERRY, SAM, DAVID, LIAM)\n\n  names = prependTitle(names)\n  println(names) // Prints:  List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n  \n\n```\n\nThe same effect has now been acheived, and our code, is much shorter, with fewer loops.  However, upon inspection, there are further oppurtunities for conciseness given that the functions `convertToUpperCase` and `prependTitle`, are meerly inbetween functions to define an anonymous function which takes a String and returns a String to pass on to `performActionToList`.\n\nConsider the following: \n\n```scala\n\n    val performActionToList = (theList: List[String], performSomeActionToElement: (String) => String) => {\n        var alteredList: List[String] = List()\n        var i = 0\n        while (i < theList.size) {\n            alteredList = performSomeActionToElement(theList(i)) :: alteredList\n            i = i + 1\n        }\n        alteredList\n    }\n\n    var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n  \n    // We now define the operation we would like applied to each element of the list inline via anonymous functions\n    names = performActionToList(names, (elem: String) => elem.toUpperCase)\n    println(names) // Prints:  List(JERRY, SAM, DAVID, LIAM)\n\n    names = performActionToList(names, (elem: String) => \"MR. \" + elem)\n    println(names) // Prints:  List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n\n```\n\nBy abstracting over the loop in such a way, we have eliminated the need for additional inbetween functions to perform well know programming constructs, IE, loops, and made it much less likely that the programmer will encounter off by one logic errors.  HOF's used in such a way are so common and powerful in functional programming, that there are a multitude of such implementations in most functional languages standard libraries, which leads to even more conciseness when defining an operation like the above.  In fact, we have in the above sections, gradually worked our way towards a naive implementation for what is know as the `map` function in functional programming.  Our example above could just as easily be refactored to: \n\n```scala\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n\n  names = names.map((elem: String) => elem.toUpperCase)\n  println(names)\n\n  names = names.map((elem: String) => \"MR. \" + elem)\n  println(names)\n\n```\n\nor using type inference ... \n \n```scala\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n\n  names = names map {_ toUpperCase}\n  println(names)\n\n  names = names map {\"MR. \" + _}\n  println(names)\n\n```\n\n##### Abstracting Over Process\n\nThinking about the uses and applications for Higher Order Functions in functional settings, benefits from a change in thinking in the programming regarding what exactly we have the possibility of abstracting over in our programs.  When we think in imperative terms, we usually think about abstraction over the data which we passing in to our functions, along with a fix set of instructions.  With HOF’s we can also think about abstracting over a subset of the processing which we will carry out on the parameter data also.  In other words, we can compose functions by stating where we would like behaviours to take place, along with the arguments which will apply to those behaviours, and inject that behaviour at function invokation time.\n","dateUpdated":"2017-02-01T14:37:28+0000","config":{"enabled":true,"graph":{"mode":"table","height":501,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/markdown","editorHide":true,"colWidth":12},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1485959799216_947994828","id":"20170131-234841_485136247","result":{"code":"SUCCESS","type":"HTML","msg":"<h3>Imperative vs Functional Sequence Loop</h3>\n<h5>The Imperative Approach</h5>\n<p>Looping over collections of objects or primative types occurs everywhere in imperative programming.  Every imperative programmer will be familiar with <code>for</code> loops in particular.  Consider the follow snippet in Java:</p>\n<pre><code class=\"java\">public static ArrayList&lt;String&gt; convertToUpperCase(ArrayList&lt;String&gt; theList) {\n\n    for(int i = 0; i &lt; theList.size(); i++) {\n        theList.set(i, theList.get(i).toUpperCase());\n    }\n\n    return theList;\n}\n\npublic static void main(String[] args) {    \n\n    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(\"liam\");\n    names.add(\"david\");\n    names.add(\"sam\");\n    names.add(\"jerry\");\n    convertToUpperCase(names);\n    System.out.print(names);  // Prints [LIAM, DAVID, SAM, JERRY]\n}\n</code></pre>\n<p>In the typically imperative style, the programmer outlines exactly how the execution of the program will proceed.  It is an abstraction over the machine, which provides an easier and higher level way of using register counters and boolean tests to loop over a sequence.  <em>Initialise an <code>int</code> counter named <code>i</code>, test to see if <code>i</code> is less than the size of our sequence, if it is, progress, if not halt.  During the loop, perform some operation and finish the loop body by <code>incrementing</code> the loop counter.</em></p>\n<p>Some time passes, and we now realise that we wish to add a title to each of the names in our collection:</p>\n<pre><code class=\"java\">public static ArrayList&lt;String&gt; prependTitle(ArrayList&lt;String&gt; theList) {\n\n    for(int i = 0; i &lt; theList.size(); i++) {\n        theList.set(i, \"MR. \" + theList.get(i));\n    }\n\n    return theList;\n}\n\npublic static ArrayList&lt;String&gt; convertToUpperCase(ArrayList&lt;String&gt; theList) {\n\n    for(int i = 0; i &lt; theList.size(); i++) {\n        theList.set(i, theList.get(i).toUpperCase());\n    }\n\n    return theList;\n}\n\npublic static void main(String[] args) {    \n\n    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();\n    names.add(\"liam\");\n    names.add(\"david\");\n    names.add(\"sam\");\n    names.add(\"jerry\");\n    convertToUpperCase(names);\n    prependTitle(names);\n    System.out.print(names);  // Prints [MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY]\n}\n</code></pre>\n<p>We have introduced an additional function named <code>prependTitle</code>, which performs another operation on our list before returning.  The similarities in form between the two functions should be readily visible in this simplified form.  However, we are forced to implement the same loop two in order to before these two operations to our ArrayList of Strings.  This not only leads to a greater amount of code, but also introduces more chance for logic errors, and index out of bounds exceptions.  Index out of bounds exceptions could of course be eliminated via a more advanced foreach loop on this particular collection, however we are still faced with the duplicated logic of the extremely common task of <strong>looping over each item in a collection once, and applying some operation to the data at the position</strong></p>\n<h5>Eliminating Code Duplication, and Providing a Higher Level of Abstraction via HOFs</h5>\n<p>As an example of how the above Java can be expressed in a more abstract way using what we know already about Higher Order Functions, and Functions as first class citizens.</p>\n<p>We will proceed from our existing implementation converted to Scala:</p>\n<pre><code class=\"scala\">/**\n    * Scala has no concept of a for loop, though we implement\n    * the same using a while.\n    * Scala additionally does not allow the passing of mutable/changeable\n    * references in to functions, for reasons which will be described\n    * much later.\n    */\n\n  val prependTitle = (theList: List[String]) =&gt; {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i &lt; theList.size) {\n      alteredList = (\"MR. \" + theList(i)) :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  val convertToUpperCase = (theList: List[String]) =&gt; {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i &lt; theList.size) {\n      alteredList = theList(i).toUpperCase :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n  names = convertToUpperCase(names)\n  println(names) // Prints: List(JERRY, SAM, DAVID, LIAM)\n\n  names = prependTitle(names)\n  println(names) // Prints: List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n</code></pre>\n<p>To take advantage of HOF's to solve our code duplication issue, we should first factor out what is common between the functions <code>prependTitle</code>, and <code>convertToUppercase</code>.  The code which we are seeking to abstract over, can be summed up as follows:</p>\n<pre><code>performActionToList(theList, performSomeActionToElement):\n    i = 0\n    while i &lt; theList:\n        theList = theList.updated(i, `performSomeActionToElement(theList(i))`)\n        i = i + 1\n    return theList\n</code></pre>\n<p>We can see from the above sample, that <code>performSomeActionToElement(theList(i))</code>, is a prime condidate for abstracting a loop via HOF's.  In this case, our <code>performSomeActionToElement(theList(i))</code> type, is a function which takes some element of type T, and returns a T as its result.  For a more concrete example in Scala,\n<br  />we will now factor out our loop:</p>\n<pre><code class=\"scala\">// Our new factored out looping construct\n\n  val performActionToList = (theList: List[String], performSomeActionToElement: (String) =&gt; String) =&gt; {\n    var alteredList: List[String] = List()\n    var i = 0\n    while (i &lt; theList.size) {\n      alteredList = performSomeActionToElement(theList(i)) :: alteredList\n      i = i + 1\n    }\n    alteredList\n  }\n\n  // Our new restructured operations on our collection\n  val convertToUpperCase  = (theList: List[String]) =&gt; performActionToList(theList, (elem: String) =&gt; elem.toUpperCase)\n  val prependTitle        = (theList: List[String]) =&gt; performActionToList(theList, (elem: String) =&gt; \"MR. \" + elem)\n\n  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n  names = convertToUpperCase(names)\n  println(names) // Prints:  List(JERRY, SAM, DAVID, LIAM)\n\n  names = prependTitle(names)\n  println(names) // Prints:  List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n</code></pre>\n<p>The same effect has now been acheived, and our code, is much shorter, with fewer loops.  However, upon inspection, there are further oppurtunities for conciseness given that the functions <code>convertToUpperCase</code> and <code>prependTitle</code>, are meerly inbetween functions to define an anonymous function which takes a String and returns a String to pass on to <code>performActionToList</code>.</p>\n<p>Consider the following:</p>\n<pre><code class=\"scala\">    val performActionToList = (theList: List[String], performSomeActionToElement: (String) =&gt; String) =&gt; {\n        var alteredList: List[String] = List()\n        var i = 0\n        while (i &lt; theList.size) {\n            alteredList = performSomeActionToElement(theList(i)) :: alteredList\n            i = i + 1\n        }\n        alteredList\n    }\n\n    var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n\n    // We now define the operation we would like applied to each element of the list inline via anonymous functions\n    names = performActionToList(names, (elem: String) =&gt; elem.toUpperCase)\n    println(names) // Prints:  List(JERRY, SAM, DAVID, LIAM)\n\n    names = performActionToList(names, (elem: String) =&gt; \"MR. \" + elem)\n    println(names) // Prints:  List(MR. LIAM, MR. DAVID, MR. SAM, MR. JERRY)\n</code></pre>\n<p>By abstracting over the loop in such a way, we have eliminated the need for additional inbetween functions to perform well know programming constructs, IE, loops, and made it much less likely that the programmer will encounter off by one logic errors.  HOF's used in such a way are so common and powerful in functional programming, that there are a multitude of such implementations in most functional languages standard libraries, which leads to even more conciseness when defining an operation like the above.  In fact, we have in the above sections, gradually worked our way towards a naive implementation for what is know as the <code>map</code> function in functional programming.  Our example above could just as easily be refactored to:</p>\n<pre><code class=\"scala\">  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n\n  names = names.map((elem: String) =&gt; elem.toUpperCase)\n  println(names)\n\n  names = names.map((elem: String) =&gt; \"MR. \" + elem)\n  println(names)\n</code></pre>\n<p>or using type inference &hellip;</p>\n<pre><code class=\"scala\">  var names = List(\"liam\", \"david\", \"sam\", \"jerry\")\n\n  names = names map {_ toUpperCase}\n  println(names)\n\n  names = names map {\"MR. \" + _}\n  println(names)\n</code></pre>\n<h5>Abstracting Over Process</h5>\n<p>Thinking about the uses and applications for Higher Order Functions in functional settings, benefits from a change in thinking in the programming regarding what exactly we have the possibility of abstracting over in our programs.  When we think in imperative terms, we usually think about abstraction over the data which we passing in to our functions, along with a fix set of instructions.  With HOF’s we can also think about abstracting over a subset of the processing which we will carry out on the parameter data also.  In other words, we can compose functions by stating where we would like behaviours to take place, along with the arguments which will apply to those behaviours, and inject that behaviour at function invokation time.</p>\n"},"dateCreated":"2017-02-01T14:36:39+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:784","dateFinished":"2017-02-01T14:37:18+0000","dateStarted":"2017-02-01T14:37:17+0000"},{"text":"","dateUpdated":"2017-02-01T14:37:17+0000","config":{"enabled":true,"tableHide":false,"graph":{"mode":"table","height":86,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","editorHide":false,"colWidth":10},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1485959799216_947994828","id":"20170131-234856_806172032","dateCreated":"2017-02-01T14:36:39+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:785","dateFinished":"2017-02-01T14:37:17+0000","dateStarted":"2017-02-01T14:37:17+0000","result":{"code":"SUCCESS","type":"TEXT","msg":""}}],"name":"test","id":"2C7FYDEY2","angularObjects":{"2C6XT11YN:shared_process":[],"2C6ZSRGJ7:shared_process":[],"2C8D4HKA1:shared_process":[],"2C9HAGK3T:shared_process":[],"2C9STYQYA:shared_process":[],"2C967DM8D:shared_process":[],"2C7XXC6A5:shared_process":[],"2C9VM77VC:shared_process":[],"2C8WN39XS:shared_process":[],"2C924Z1D7:shared_process":[],"2C8FEU912:shared_process":[],"2C98A1GEY:shared_process":[],"2C7A5SXCE:shared_process":[],"2CAQA2BUC:shared_process":[],"2C8ZM82AB:shared_process":[],"2C7XKRY57:shared_process":[],"2C8K32X2V:shared_process":[],"2C8T4YH3G:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}