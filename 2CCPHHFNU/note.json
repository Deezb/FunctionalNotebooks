{"paragraphs":[{"text":"%md\n\n# Currying and Partially Applied Functions.\n\n### Building on Higher Order Functions.\n\nGiven what we learned about Higher Order Functions in the previous sections, and how they can be used to express flexible code in a concise manner (via a demonstration of taking imperative constructs and devising a functional implementation to overcome some of its shortcomings), It has been shown that being able to deal with functions as a kind of data is beneficial in and of itself.\n\nCurrying and Partially Applied Functions build on the concept of higher order functions, to allow for even further code flexibility.\n\n#### Currying\n\nHaving understood Higher Order Functions, it should now make sense to describe Currying as follows: \n\nA Curried function, is a multi parameter function, which instead of taking all parameters in one block, instead takes a single parameter at each position, and returns another function which takes the next argument in the sequence as its argument.  This continues up until the final parameter, at which point the arguments passed in are evaluated, and a results is returned.  \n\nFor a concrete example of this, consider the following simple yet frequently given example ... \n\n```scala\nval simpleAdd: (Int, Int) => Int = (x, y) => x + y\nsimpleAdd(1, 2)\n```\nA standard scala function which takes two ints, and returns an int by adding them together.\n\n```scala\nval curriedAdd: Int => Int => Int = x => y => x + y\ncurriedAdd(1)(2)\n```\n\nAnd now, the same function in curried form.  Note that the type of this val can be read as 'A function which takes an Int, and returns a function which takes an int and returns an int.'\n\nThere are a few things of importance to note in the above curried function.  Firstly, the definition is using some scala syntactic sugar to make the definition of the function short.  In fact, it could be represented in a more concise manner using type inferance.\n\n```scala\nval curriedAddShortest = (x: Int) => (y: Int) => x + y\n```\n\nHowever, it is beneficial to extract this out into its most verbose form for learning purposes: \n\n```scala\n\nval curriedAddVerbose: Int => (Int => Int) = {\n  (x: Int) => {\n    (y: Int) => {\n      x + y\n    }\n  }\n}\n\n```\n\nWhen expressed in this form, it may be clearer to understand exactly what is going on with the function.\n\nIf we call the above function with the single parameter x, we see that the function body of this definition, itself returns a single parameter function which takes a y, and as its body defines that x and y should be added together.  It may seem that this all happens in one invokation of the function curriedAddVerbose, however this is not the case.  We should again look at the syntax of calling this curried function to understand how we are using it and the implications of currying.\n\n```scala\ncurriedAddVerbose(1)(2) \n/* vs */ \nsimpleAdd(1, 2)\n```\n \nIn the above example, what is actually happening in the invokation of curriedAddVerbose, is that the function which is being returned after the initial invokation (curriedAddVerbose(1)), is itself being immediately invoked with the argument 2, and then is discarded.  It would as well, be perfectly valid to perform the following operations:\n\n```scala\ncurriedAddVerbose(1)(2)     //3\ncurriedAddVerbose(1)        //Int => Int\n\n//Just as we can assign the return of '3' to a variable, we may also assign our returned HOF for later use.\n\nval oneAdd = curriedAddVerbose(1)\n\n/*\n*   At this point, oneAdd contains the following implementation\n*   (y: Int) => {\n*        x + y\n*   }\n*/\n\noneAdd(4)   //5\noneAdd(6)   //7\noneAdd(1)   //2\n\n```\nIt is reasonable to ask, coming from an imperative background, just how this inner function may access the value of x even though it is in another scope, and especiialy as the duration of variables within functions is usually exhausted when the function which defines them ends.  \nThis requires a short aside to explain a property known as 'Closure'.\n\n##### Closure\n\nClosure can in simple terms be thought of as the 'capture' of a variables state at an instance in time.  Closure is acheived, when an anonomous function or lambda, references a varible in a parent scope.  In our add examples, the first time our curried function is called with a single parameter, the value of x is set, and the next HOF in the chain is returned.  As this HOF itself references x.  The value which we previously injected is set within that function, and ready to be used when the final function in the chain is executed.\n\nThis is essentially all there is to Currying, though the usefulness of this technique may not be appearant in such a simple example, and we will return to a more complicated use later.\n\n\n#### Partially Applied Functions\n\nOnce Currying is understood, Paritially Applied Functions are much more readily understood.  A limitation which may jump out around Curried functions immediately, is that we must make a judgement call ahead of time regarding which parameters we would like to 'build up' and in which order.  For instance, if we have the following definition: \n\n```scala\nval sampleFun: Int => Double => String => String = \n  i => d => s => {\n    s + s\"$d, $i\"\n  }\n```\nThen, we must be sure that we want to apply this function in the order Int, Double, and String.  As a general rule, it is best to think of parameter positions in curried functions as becoming more specialized and less general the further to the right in the parameter list we travel.\n\nParially Applied Functions functions overcome this limitation of needing to decide ahead of time the order of the inputs, and can generally be compared with Curried functions as follows:  Where a Curried function takes a single parameter and returns a function which itself takes a single parameter untill the final invokation where an evaluated result of those functions is return, a partially applied function may be a function of N parameters, on which an invokation of A parameters may take place in any order (where A <= N and A > 0), which returns a new function which takes N - A parameters until the final invokation where a result is produced.\n\nFor a simple example: \n\n```scala\ndef count(one: Int, two: Int, three: Int): Unit = {\n    Console println s\"$one, $two, $three\"\n}\n\n//May be invoked as: \n\nval missingMiddle = count(1, _: Int, 3) // Int => Unit\nmissingMiddle(2)    // \"1, 2, 3\"\n\n\n```\n\n### Using Curring and Partially Applied Functions to Solve Problems.\n\nCurrying and PAF's can be difficult to visualize a use for, however, there are two immediate benefits which can be realised when forming a system around them.  Consider the following system, which deals with payments:\n\n```scala\n\ntype Cardnumber           = String\ntype Item                 = String\ntype Price                = Double\ntype Receipt              = String\ntype Payment              = (Cardnumber, Item, Price) => Receipt\ntype SendInvoice          = Receipt     => Receipt\ntype PaymentValidation    = Cardnumber  => Boolean\ntype Checkout             = Payment\n\nval performPayment: (PaymentValidation, Payment, SendInvoice, (Cardnumber, Item, Price)) => Receipt = {\n\n  (valid, pay, sendInvoice, details) => {\n\n    val (card, item, price) = details\n\n    if (valid(card)) {\n      val payment = pay(card, item, price)\n      sendInvoice(payment)\n    } else {\n      \"This is an invalid card.\"\n    }\n  }\n}\n\nval cPerformPaymentCurried = performPayment.curried\n\n```\n\nWe first define a top level function which deals with a payment.  It exists at a high level conceptually in the code, as it deals with many HOF's, until finally taking a card, item, and price, in order to evaluate its return.  The first three arguments in our function above are curried.  We will now see some functions which could be injected at these locations:\n\n```scala\n\nval isValidGoldCard   : PaymentValidation = (cardnumber) => cardnumber.length == 4\nval isValidSilverCard : PaymentValidation = (cardnumber) => cardnumber.length == 6\nval invoiceByPost     : SendInvoice = (receipt) => receipt + \"We have sent your invoice by post.\"\nval invoiceByEmail    : SendInvoice = (receipt) => receipt + \"We have sent your invoice by email.\"\nval payBySilvercard   : Payment = (card, item, price) => s\"Your Receipt for the Silver Card: $card | $item | €$price\\n\"\nval payByGoldcard     : Payment = (card, item, price)     => s\"Your Receipt for the Gold Card: $card | $item | €$price\\n\"\n\n```\n\nThe Types of these functions match the types in the the function signiture of our cPerformPaymentMethod, so we may build up a chain of computations by applying those functions: \n\n```scala\n\nval goldMemberService   = cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\nval silverMemberService = cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\n\nval goldPurchase    = silverMemberService(invoiceByPost)\nval silverPurchase  = goldMemberService(invoiceByPost)\n\n```\n\nWe have now built two distinct functions, which are ready to be applied to their final arguments to be evaluated to a result.\n\n```scala\n\nsilverPurchase(\"1234\", \"Table Set\", 100.0)  //This is an invalid card.\n\ngoldPurchase(\"1234\", \"Table Set\", 100.0)    //Your Receipt for the Gold Card: 1234 | Table Set | €100.0\n                                            //We have sent your invoice by post.\n\n```\n\nThere are two important things to note here.\n\n1. We formed a new implementation based off existing functionality via injecting and building our computation an argument at a time.\n\nThis first property allows for easy testing, when we consider that in our testing functions, we could just as easiliy apply a mock function.  The following defines a test utility function which always evaluates to true, and builds up a test function which would imply that the 'payByGoldcard' is being tested for some property.\n\n```scala\nval MOCKED_VALIDATION: PaymentValidation = (_) => true\nval payByGoldCardTestFun = cPerformPaymentCurried(MOCKED_VALIDATION)(payByGoldcard)\n\n```\n\n2. The final stage of the function invokation has no concept of the outer services which define its implementation.\n\nAt the final stage of the invokation, the arguments which we apply relate directly to the item we are purchasing.  In an imperative realm, provided we have no external global state, this would imply that all of the validation and other processing defined in the business process, would be carried out and instanciated within the function, which would make the function very hard, if not impossible to test.\n\nHowever, with currying, we were able to inject our dependencies early in the formation of a few top level functions, and avoid the noise of explicitly passing our dependencies to every function which uses them.  We instead, can focus on only passing in the concrete product we wish to deal with.\n\nCurrying and Partially Applied Functions provide a powerful mechanism for composing a system via a series of curried and partially applied functions, which are finally applied to their concrete arguments at the periphery of the system directly at the IO interface in the code.  All of this is possible while still maintaining flexibility, and makes for easy testing without any additional frameworks or boilerplate, by using only functional programming features.\n\n\n\n\n\n","user":"anonymous","dateUpdated":"2017-03-03T07:44:59+0000","config":{"enabled":true,"tableHide":false,"editorMode":"ace/mode/markdown","results":[{"graph":{"mode":"table","height":4423.390625,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"editorSetting":{"language":"markdown","editOnDblClick":true},"editorHide":true,"colWidth":9},"settings":{"params":{"payBy":""},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Currying and Partially Applied Functions.</h1>\n<h3>Building on Higher Order Functions.</h3>\n<p>Given what we learned about Higher Order Functions in the previous sections, and how they can be used to express flexible code in a concise manner (via a demonstration of taking imperative constructs and devising a functional implementation to overcome some of its shortcomings), It has been shown that being able to deal with functions as a kind of data is beneficial in and of itself.</p>\n<p>Currying and Partially Applied Functions build on the concept of higher order functions, to allow for even further code flexibility.</p>\n<h4>Currying</h4>\n<p>Having understood Higher Order Functions, it should now make sense to describe Currying as follows: </p>\n<p>A Curried function, is a multi parameter function, which instead of taking all parameters in one block, instead takes a single parameter at each position, and returns another function which takes the next argument in the sequence as its argument. This continues up until the final parameter, at which point the arguments passed in are evaluated, and a results is returned. </p>\n<p>For a concrete example of this, consider the following simple yet frequently given example &hellip; </p>\n<pre><code class=\"scala\">val simpleAdd: (Int, Int) =&gt; Int = (x, y) =&gt; x + y\nsimpleAdd(1, 2)\n</code></pre>\n<p>A standard scala function which takes two ints, and returns an int by adding them together.</p>\n<pre><code class=\"scala\">val curriedAdd: Int =&gt; Int =&gt; Int = x =&gt; y =&gt; x + y\ncurriedAdd(1)(2)\n</code></pre>\n<p>And now, the same function in curried form. Note that the type of this val can be read as &lsquo;A function which takes an Int, and returns a function which takes an int and returns an int.&rsquo;</p>\n<p>There are a few things of importance to note in the above curried function. Firstly, the definition is using some scala syntactic sugar to make the definition of the function short. In fact, it could be represented in a more concise manner using type inferance.</p>\n<pre><code class=\"scala\">val curriedAddShortest = (x: Int) =&gt; (y: Int) =&gt; x + y\n</code></pre>\n<p>However, it is beneficial to extract this out into its most verbose form for learning purposes: </p>\n<pre><code class=\"scala\"><br/>val curriedAddVerbose: Int =&gt; (Int =&gt; Int) = {\n  (x: Int) =&gt; {\n    (y: Int) =&gt; {\n      x + y\n    }\n  }\n}\n\n</code></pre>\n<p>When expressed in this form, it may be clearer to understand exactly what is going on with the function.</p>\n<p>If we call the above function with the single parameter x, we see that the function body of this definition, itself returns a single parameter function which takes a y, and as its body defines that x and y should be added together. It may seem that this all happens in one invokation of the function curriedAddVerbose, however this is not the case. We should again look at the syntax of calling this curried function to understand how we are using it and the implications of currying.</p>\n<pre><code class=\"scala\">curriedAddVerbose(1)(2) \n/* vs */ \nsimpleAdd(1, 2)\n</code></pre>\n<p>In the above example, what is actually happening in the invokation of curriedAddVerbose, is that the function which is being returned after the initial invokation (curriedAddVerbose(1)), is itself being immediately invoked with the argument 2, and then is discarded. It would as well, be perfectly valid to perform the following operations:</p>\n<pre><code class=\"scala\">curriedAddVerbose(1)(2)     //3\ncurriedAddVerbose(1)        //Int =&gt; Int\n\n//Just as we can assign the return of &#39;3&#39; to a variable, we may also assign our returned HOF for later use.\n\nval oneAdd = curriedAddVerbose(1)\n\n/*\n*   At this point, oneAdd contains the following implementation\n*   (y: Int) =&gt; {\n*        x + y\n*   }\n*/\n\noneAdd(4)   //5\noneAdd(6)   //7\noneAdd(1)   //2\n\n</code></pre>\n<p>It is reasonable to ask, coming from an imperative background, just how this inner function may access the value of x even though it is in another scope, and especiialy as the duration of variables within functions is usually exhausted when the function which defines them ends.<br/>This requires a short aside to explain a property known as &lsquo;Closure&rsquo;.</p>\n<h5>Closure</h5>\n<p>Closure can in simple terms be thought of as the &lsquo;capture&rsquo; of a variables state at an instance in time. Closure is acheived, when an anonomous function or lambda, references a varible in a parent scope. In our add examples, the first time our curried function is called with a single parameter, the value of x is set, and the next HOF in the chain is returned. As this HOF itself references x. The value which we previously injected is set within that function, and ready to be used when the final function in the chain is executed.</p>\n<p>This is essentially all there is to Currying, though the usefulness of this technique may not be appearant in such a simple example, and we will return to a more complicated use later.</p>\n<h4>Partially Applied Functions</h4>\n<p>Once Currying is understood, Paritially Applied Functions are much more readily understood. A limitation which may jump out around Curried functions immediately, is that we must make a judgement call ahead of time regarding which parameters we would like to &lsquo;build up&rsquo; and in which order. For instance, if we have the following definition: </p>\n<pre><code class=\"scala\">val sampleFun: Int =&gt; Double =&gt; String =&gt; String = \n  i =&gt; d =&gt; s =&gt; {\n    s + s&quot;$d, $i&quot;\n  }\n</code></pre>\n<p>Then, we must be sure that we want to apply this function in the order Int, Double, and String. As a general rule, it is best to think of parameter positions in curried functions as becoming more specialized and less general the further to the right in the parameter list we travel.</p>\n<p>Parially Applied Functions functions overcome this limitation of needing to decide ahead of time the order of the inputs, and can generally be compared with Curried functions as follows: Where a Curried function takes a single parameter and returns a function which itself takes a single parameter untill the final invokation where an evaluated result of those functions is return, a partially applied function may be a function of N parameters, on which an invokation of A parameters may take place in any order (where A &lt;= N and A &gt; 0), which returns a new function which takes N - A parameters until the final invokation where a result is produced.</p>\n<p>For a simple example: </p>\n<pre><code class=\"scala\">def count(one: Int, two: Int, three: Int): Unit = {\n    Console println s&quot;$one, $two, $three&quot;\n}\n\n//May be invoked as: \n\nval missingMiddle = count(1, _: Int, 3) // Int =&gt; Unit\nmissingMiddle(2)    // &quot;1, 2, 3&quot;\n\n\n</code></pre>\n<h3>Using Curring and Partially Applied Functions to Solve Problems.</h3>\n<p>Currying and PAF&rsquo;s can be difficult to visualize a use for, however, there are two immediate benefits which can be realised when forming a system around them. Consider the following system, which deals with payments:</p>\n<pre><code class=\"scala\"><br/>type Cardnumber           = String\ntype Item                 = String\ntype Price                = Double\ntype Receipt              = String\ntype Payment              = (Cardnumber, Item, Price) =&gt; Receipt\ntype SendInvoice          = Receipt     =&gt; Receipt\ntype PaymentValidation    = Cardnumber  =&gt; Boolean\ntype Checkout             = Payment\n\nval performPayment: (PaymentValidation, Payment, SendInvoice, (Cardnumber, Item, Price)) =&gt; Receipt = {\n\n  (valid, pay, sendInvoice, details) =&gt; {\n\n    val (card, item, price) = details\n\n    if (valid(card)) {\n      val payment = pay(card, item, price)\n      sendInvoice(payment)\n    } else {\n      &quot;This is an invalid card.&quot;\n    }\n  }\n}\n\nval cPerformPaymentCurried = performPayment.curried\n\n</code></pre>\n<p>We first define a top level function which deals with a payment. It exists at a high level conceptually in the code, as it deals with many HOF&rsquo;s, until finally taking a card, item, and price, in order to evaluate its return. The first three arguments in our function above are curried. We will now see some functions which could be injected at these locations:</p>\n<pre><code class=\"scala\"><br/>val isValidGoldCard   : PaymentValidation = (cardnumber) =&gt; cardnumber.length == 4\nval isValidSilverCard : PaymentValidation = (cardnumber) =&gt; cardnumber.length == 6\nval invoiceByPost     : SendInvoice = (receipt) =&gt; receipt + &quot;We have sent your invoice by post.&quot;\nval invoiceByEmail    : SendInvoice = (receipt) =&gt; receipt + &quot;We have sent your invoice by email.&quot;\nval payBySilvercard   : Payment = (card, item, price) =&gt; s&quot;Your Receipt for the Silver Card: $card | $item | €$price\\n&quot;\nval payByGoldcard     : Payment = (card, item, price)     =&gt; s&quot;Your Receipt for the Gold Card: $card | $item | €$price\\n&quot;\n\n</code></pre>\n<p>The Types of these functions match the types in the the function signiture of our cPerformPaymentMethod, so we may build up a chain of computations by applying those functions: </p>\n<pre><code class=\"scala\"><br/>val goldMemberService   = cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\nval silverMemberService = cPerformPaymentCurried(isValidGoldCard)(payByGoldcard)\n\nval goldPurchase    = silverMemberService(invoiceByPost)\nval silverPurchase  = goldMemberService(invoiceByPost)\n\n</code></pre>\n<p>We have now built two distinct functions, which are ready to be applied to their final arguments to be evaluated to a result.</p>\n<pre><code class=\"scala\"><br/>silverPurchase(&quot;1234&quot;, &quot;Table Set&quot;, 100.0)  //This is an invalid card.\n\ngoldPurchase(&quot;1234&quot;, &quot;Table Set&quot;, 100.0)    //Your Receipt for the Gold Card: 1234 | Table Set | €100.0\n                                            //We have sent your invoice by post.\n\n</code></pre>\n<p>There are two important things to note here.</p>\n<ol>\n  <li>We formed a new implementation based off existing functionality via injecting and building our computation an argument at a time.</li>\n</ol>\n<p>This first property allows for easy testing, when we consider that in our testing functions, we could just as easiliy apply a mock function. The following defines a test utility function which always evaluates to true, and builds up a test function which would imply that the &lsquo;payByGoldcard&rsquo; is being tested for some property.</p>\n<pre><code class=\"scala\">val MOCKED_VALIDATION: PaymentValidation = (_) =&gt; true\nval payByGoldCardTestFun = cPerformPaymentCurried(MOCKED_VALIDATION)(payByGoldcard)\n\n</code></pre>\n<ol>\n  <li>The final stage of the function invokation has no concept of the outer services which define its implementation.</li>\n</ol>\n<p>At the final stage of the invokation, the arguments which we apply relate directly to the item we are purchasing. In an imperative realm, provided we have no external global state, this would imply that all of the validation and other processing defined in the business process, would be carried out and instanciated within the function, which would make the function very hard, if not impossible to test.</p>\n<p>However, with currying, we were able to inject our dependencies early in the formation of a few top level functions, and avoid the noise of explicitly passing our dependencies to every function which uses them. We instead, can focus on only passing in the concrete product we wish to deal with.</p>\n<p>Currying and Partially Applied Functions provide a powerful mechanism for composing a system via a series of curried and partially applied functions, which are finally applied to their concrete arguments at the periphery of the system directly at the IO interface in the code. All of this is possible while still maintaining flexibility, and makes for easy testing without any additional frameworks or boilerplate, by using only functional programming features.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1488505645050_-1297417266","id":"20170130-221237_1038500617","dateCreated":"2017-03-03T01:47:25+0000","dateStarted":"2017-03-03T07:44:59+0000","dateFinished":"2017-03-03T07:44:59+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:6917"},{"text":"","dateUpdated":"2017-03-03T01:47:25+0000","config":{"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"editorMode":"ace/mode/scala","results":{},"editorSetting":{"language":"scala"},"colWidth":12},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1488505645061_-35056125","id":"20170201-175546_248826486","dateCreated":"2017-03-03T01:47:25+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:6918"}],"name":"Currying and Partially Applied Functions","id":"2CCR6RRS8","angularObjects":{"2CAVXEDGR:shared_process":[],"2CC93329H:shared_process":[],"2CCKTWRVG:shared_process":[],"2CD8WKTCR:shared_process":[],"2C9M3RD9V:shared_process":[],"2CAJVHYCR:shared_process":[],"2CBPU2EHU:shared_process":[],"2CB3ANSKC:shared_process":[],"2CAM6PBJ6:shared_process":[],"2CCEDH17P:shared_process":[],"2CAB4CEVS:shared_process":[],"2CC2W5B1D:shared_process":[],"2CBZQGDUA:shared_process":[],"2CAXVKKBX:shared_process":[],"2C9TKKRAH:shared_process":[],"2CAV4W5B6:shared_process":[],"2C9A3SC2K:shared_process":[],"2C9Q9FW4X:shared_process":[],"2C9H6ESHD:shared_process":[],"2CAK3VSPJ:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}